// 파일 위치: components/aivoca/components/QuizMode.tsx

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Word } from '../types'; // 주소를 우리 프로젝트에 맞게 수정!
import { validateAnswerWithAI, generatePronunciation } from '../services/geminiService'; // 주소를 우리 프로젝트에 맞게 수정!
import { CheckCircle, XCircle, ArrowRight, Check, X, Home, RotateCcw, Shuffle, ListChecks, Star, Loader2, Lightbulb, Brain, Volume2, Clock, Timer, Zap, FastForward } from 'lucide-react';

// ... (이 아래는 네가 준 코드와 99% 똑같아. 주소만 고쳤어!)
interface QuizModeProps { words: Word[]; allWords?: Word[]; quizMode?: 'TYPING' | 'MULTIPLE_CHOICE' | 'OX'; timeLimit?: number; onSave: (results: { correct: string[], incorrect: string[] }) => void; onRetry: (mode: 'ALL' | 'INCORRECT', results: { correct: string[], incorrect: string[] }) => void; onExit: () => void; onToggleFavorite: (id: string) => void; hasNextBatch?: boolean; onNextBatch?: () => void; }
type Step = 'INPUT' | 'GRADING' | 'SUMMARY';
interface UserAnswerRecord { word: Word; userInput: string; isCorrect: boolean; isAiCorrect: boolean; originalVerdict?: boolean; aiFeedback?: string; }
const LOCK_DURATION = 600;

const QuizMode: React.FC<QuizModeProps> = ({ words, allWords = [], quizMode = 'TYPING', timeLimit, onSave, onRetry, onExit, onToggleFavorite, hasNextBatch, onNextBatch }) => {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [step, setStep] = useState<Step>('INPUT');
  const [currentInput, setCurrentInput] = useState('');
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [timeLeft, setTimeLeft] = useState<number | undefined>(timeLimit);
  const [answerHistory, setAnswerHistory] = useState<UserAnswerRecord[]>([]);
  const [options, setOptions] = useState<string[]>([]);
  const [oxState, setOxState] = useState<{ displayedDefinition: string, isTrue: boolean }>({ displayedDefinition: '', isTrue: true });
  const [showHint, setShowHint] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const audioCtxRef = useRef<AudioContext | null>(null);
  const isLockedRef = useRef(false);
  const validationPromisesRef = useRef<Promise<any>[]>([]);

  useEffect(() => { if (!audioCtxRef.current) { audioCtxRef.current = new (window.AudioContext || (window as any).webkitAudioContext)({sampleRate: 24000}); } if (audioCtxRef.current.state === 'suspended') { audioCtxRef.current.resume(); } return () => { audioCtxRef.current?.close(); audioCtxRef.current = null; }; }, []);
  const handleTimeout = () => { const missingRecords: UserAnswerRecord[] = []; for (let i = currentIndex; i < words.length; i++) { missingRecords.push({ word: words[i], userInput: '시간 초과 (Time Over)', isCorrect: false, isAiCorrect: false, originalVerdict: false, aiFeedback: '제한 시간이 종료되었습니다.' }); } setAnswerHistory(prev => [...prev, ...missingRecords]); setStep('GRADING'); };
  useEffect(() => { if (timeLeft === undefined || step !== 'INPUT') return; const timer = setInterval(() => { setTimeLeft((prev) => { if (prev !== undefined && prev <= 1) { clearInterval(timer); handleTimeout(); return 0; } return prev !== undefined ? prev - 1 : undefined; }); }, 1000); return () => clearInterval(timer); }, [timeLeft, step]);
  useEffect(() => { const nextIdx = currentIndex + 1; if (nextIdx < words.length) { generatePronunciation(words[nextIdx].term); } if (currentIndex < words.length) { generatePronunciation(words[currentIndex].term); } }, [currentIndex, words]);
  const playSound = useCallback((type: 'correct' | 'incorrect' | 'click') => { const ctx = audioCtxRef.current; if (!ctx) return; const oscillator = ctx.createOscillator(); const gainNode = ctx.createGain(); oscillator.connect(gainNode); gainNode.connect(ctx.destination); const now = ctx.currentTime; if (type === 'correct') { oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(523.25, now); oscillator.frequency.exponentialRampToValueAtTime(1046.50, now + 0.1); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3); oscillator.start(); oscillator.stop(now + 0.3); } else if (type === 'incorrect') { oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(150, now); oscillator.frequency.linearRampToValueAtTime(100, now + 0.2); gainNode.gain.setValueAtTime(0.1, now); gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3); oscillator.start(); oscillator.stop(now + 0.3); } else { oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(800, now); gainNode.gain.setValueAtTime(0.05, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1); oscillator.start(); oscillator.stop(now + 0.1); } }, []);
  const speak = async (text: string, isPrefetch = false) => { if (isSpeaking && !isPrefetch) return; if (!isPrefetch) setIsSpeaking(true); try { const pcmData = await generatePronunciation(text); if (isPrefetch) return; if (pcmData && audioCtxRef.current) { const ctx = audioCtxRef.current; if (ctx.state === 'suspended') await ctx.resume(); const numChannels = 1; const dataInt16 = new Int16Array(pcmData.buffer); const frameCount = dataInt16.length; const audioBuffer = ctx.createBuffer(numChannels, frameCount, 24000); const channelData = audioBuffer.getChannelData(0); for (let i = 0; i < frameCount; i++) { channelData[i] = dataInt16[i] / 32768.0; } const source = ctx.createBufferSource(); source.buffer = audioBuffer; source.connect(ctx.destination); source.onended = () => setIsSpeaking(false); source.start(); } else { setIsSpeaking(false); } } catch (error) { console.error("Audio playback error", error); setIsSpeaking(false); } };
  const currentWord = words[currentIndex];
  useEffect(() => { if (step !== 'INPUT') return; const timer = setTimeout(() => { isLockedRef.current = false; if (quizMode === 'TYPING') { inputRef.current?.focus(); } }, 100); const sourceList = allWords.length > 0 ? allWords : words; if (quizMode === 'MULTIPLE_CHOICE') { const correctAnswer = currentWord.definition; const potentialDistractors = sourceList.filter(w => w.definition !== correctAnswer).map(w => w.definition); const shuffledDistractors = potentialDistractors.sort(() => 0.5 - Math.random()); const selectedDistractors = shuffledDistractors.slice(0, 3); const finalOptions = [correctAnswer, ...selectedDistractors].sort(() => 0.5 - Math.random()); setOptions(finalOptions); } if (quizMode === 'OX') { const isTrue = Math.random() > 0.5 || sourceList.length < 2; if (isTrue) { setOxState({ displayedDefinition: currentWord.definition, isTrue: true }); } else { const potentialDistractors = sourceList.filter(w => w.definition !== currentWord.definition); const distractor = potentialDistractors[Math.floor(Math.random() * potentialDistractors.length)]; setOxState({ displayedDefinition: distractor.definition, isTrue: false }); } } setShowHint(false); setCurrentInput(''); return () => clearTimeout(timer); }, [currentIndex, quizMode, step, currentWord, words, allWords]);
  const getChosung = (str: string) => { const chosung = ["ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ", "ㅂ", "ㅃ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅉ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"]; let result = ""; for (let i = 0; i < str.length; i++) { const code = str.charCodeAt(i) - 44032; if (code > -1 && code < 11172) { result += chosung[Math.floor(code / 588)]; } else { result += str.charAt(i); } } return result; }
  const processFinalGrading = async () => { const resolvedValidations = await Promise.all(validationPromisesRef.current); const finalResults = answerHistory.map((record, idx) => { if (record.isCorrect && record.originalVerdict) return record; if (record.userInput.includes('Time Over')) return record; if (quizMode === 'TYPING' && !record.isCorrect) { const aiResult = resolvedValidations[idx]; if (aiResult) { return { ...record, isCorrect: aiResult.isCorrect, isAiCorrect: aiResult.isCorrect, aiFeedback: aiResult.explanation }; } } return record; }); setAnswerHistory(finalResults); setStep('SUMMARY'); };
  useEffect(() => { if (step === 'GRADING') { processFinalGrading(); } }, [step]);
  const checkLocal = (word: Word, input: string) => { if (!input) return false; const normalize = (str: string) => str.replace(/\s+/g, '').toLowerCase().replace(/[.,;]/g, ''); const inputNorm = normalize(input); const defNorm = normalize(word.definition); if (inputNorm === defNorm) return true; if (defNorm.includes(inputNorm) && inputNorm.length >= 2) return true; const tokenize = (text: string) => text.split(/[,;/]+/).map(t => t.replace(/\s+/g, '').toLowerCase()).filter(t => t.length > 0); const inputTokens = tokenize(input); const defTokens = tokenize(word.definition); return inputTokens.length > 0 && inputTokens.every(t => defTokens.includes(t)); };
  const submitAnswerWithLogic = (inputVal: string | boolean) => { if (isLockedRef.current) return; isLockedRef.current = true; if (document.activeElement instanceof HTMLElement) { document.activeElement.blur(); } let isCorrect = false; let stringInput = ''; let validationPromise = Promise.resolve(null); if (quizMode === 'OX') { const userBool = inputVal as boolean; isCorrect = (userBool === oxState.isTrue); stringInput = userBool ? "O" : "X"; } else if (quizMode === 'MULTIPLE_CHOICE') { const val = inputVal as string; isCorrect = (val === currentWord.definition); stringInput = val; } else { stringInput = currentInput; isCorrect = checkLocal(currentWord, stringInput); if (!isCorrect) { validationPromise = validateAnswerWithAI(currentWord.term, currentWord.definition, stringInput); } } validationPromisesRef.current.push(validationPromise); const record: UserAnswerRecord = { word: currentWord, userInput: stringInput, isCorrect: isCorrect, isAiCorrect: false, originalVerdict: isCorrect }; setAnswerHistory(prev => [...prev, record]); playSound('click'); setTimeout(() => { if (currentIndex < words.length - 1) { setCurrentIndex(prev => prev + 1); } else { setStep('GRADING'); isLockedRef.current = false; } }, 50); };
  useEffect(() => { const handleKeyDown = (e: KeyboardEvent) => { if (step !== 'INPUT') return; if (isLockedRef.current) { e.preventDefault(); return; } if (quizMode === 'MULTIPLE_CHOICE') { if (['1', '2', '3', '4'].includes(e.key)) { e.preventDefault(); const idx = parseInt(e.key) - 1; if (options[idx]) submitAnswerWithLogic(options[idx]); } } else if (quizMode === 'OX') { if (['o', 'O', '1'].includes(e.key)) { e.preventDefault(); submitAnswerWithLogic(true); } if (['x', 'X', '2'].includes(e.key)) { e.preventDefault(); submitAnswerWithLogic(false); } } else if (quizMode === 'TYPING') { if (e.key === 'Enter') { e.preventDefault(); if (!e.repeat) { submitAnswerWithLogic(currentInput); } } } if (e.key === 'Escape') { e.preventDefault(); submitAnswerWithLogic(quizMode === 'OX' ? !oxState.isTrue : ''); } }; window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [step, currentIndex, quizMode, options, oxState, currentInput]);
  const formatTime = (seconds: number) => { const m = Math.floor(seconds / 60); const s = seconds % 60; return `${m}분 ${s.toString().padStart(2, '0')}초`; };

  if (step === 'GRADING') { return (<div className="flex flex-col items-center justify-center min-h-[60vh] animate-fade-in text-center p-4"><Brain className="w-20 h-20 text-purple-500 mb-6 animate-pulse" /><h2 className="text-2xl font-bold text-white mb-2">AI 선생님이 채점 중입니다...</h2><p className="text-slate-400 max-w-md">백그라운드에서 이미 분석을 마쳤습니다. <br/><span className="text-indigo-400 font-semibold">잠시만 기다려주세요!</span></p><Loader2 className="w-8 h-8 text-purple-500 mt-8 animate-spin" /></div>); }
  if (step === 'SUMMARY') { const correctCount = answerHistory.filter(r => r.isCorrect).length; const incorrectCount = answerHistory.length - correctCount; const score = Math.round((correctCount / words.length) * 100); const correctIds = answerHistory.filter(r => r.isCorrect).map(r => r.word.id); const incorrectIds = answerHistory.filter(r => !r.isCorrect).map(r => r.word.id); return (<div className="max-w-3xl mx-auto p-4 animate-slide-up pb-20"><div className="bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl overflow-hidden"><div className="bg-slate-800 p-6 flex flex-col items-center border-b border-slate-700 relative overflow-hidden"><div className="absolute inset-0 bg-gradient-to-b from-purple-500/10 to-transparent"></div><div className="relative z-10 text-center w-full"><div className="text-sm text-slate-400 uppercase tracking-widest mb-1">Final Score</div><div className="text-5xl font-black text-white mb-2">{score}점</div><div className="flex justify-center gap-4 text-sm font-medium mb-4"><span className="text-green-400 flex items-center gap-1"><CheckCircle className="w-4 h-4"/> 정답 {correctCount}</span><span className="text-red-400 flex items-center gap-1"><XCircle className="w-4 h-4"/> 오답 {incorrectCount}</span></div>{timeLimit !== undefined && timeLeft !== undefined && (<div className="bg-slate-900/50 border border-slate-600 rounded-xl p-3 inline-flex flex-col items-center animate-pulse-glow shadow-lg max-w-xs mx-auto w-full"><span className="text-yellow-400 text-xs font-bold uppercase tracking-wider flex items-center gap-1 mb-1"><Zap className="w-3 h-3 fill-yellow-400"/> Speed Mode Result</span><div className="text-white font-mono font-bold text-lg">⏱ {formatTime(timeLimit - timeLeft)} <span className="text-slate-500 text-sm font-normal">/ {formatTime(timeLimit)}</span></div><div className={`text-xs mt-1 font-bold ${timeLeft === 0 ? 'text-red-400' : 'text-green-400'}`}>{timeLeft === 0 ? "시간 초과 (Time Over)" : "미션 성공 (Mission Clear!)"}</div></div>)}</div></div><div className="p-6"><h3 className="text-lg font-bold text-white mb-4 flex items-center gap-2"><ListChecks className="w-5 h-5 text-indigo-400"/> 상세 채점 결과</h3><div className="space-y-3">{answerHistory.map((record, idx) => { const currentWordState = words.find(w => w.id === record.word.id) || record.word; return (<div key={idx} className={`flex flex-col md:flex-row md:items-center gap-4 p-4 rounded-xl border ${record.isCorrect ? 'bg-slate-800/50 border-slate-700' : 'bg-red-900/10 border-red-900/30'}`}><div className="hidden md:flex flex-col items-center justify-center w-12 shrink-0">{record.isCorrect ? (record.isAiCorrect ? <div className="flex flex-col items-center text-green-400"><Brain className="w-6 h-6"/><span className="text-[10px] font-bold mt-1">AI인정</span></div> : <CheckCircle className="w-6 h-6 text-green-500"/>) : (<XCircle className="w-6 h-6 text-red-500"/>)}</div><div className="flex-1 min-w-0"><div className="flex items-center gap-2 mb-1"><span className="text-lg font-bold text-white">{currentWordState.term}</span><button onClick={() => onToggleFavorite(currentWordState.id)} className="p-1 group"><Star className={`w-4 h-4 transition-transform group-active:scale-125 ${currentWordState.isFavorite ? 'fill-yellow-400 text-yellow-400' : 'text-slate-600'}`} /></button><button onClick={() => speak(currentWordState.term)} className={`p-1 transition-colors ${isSpeaking ? 'text-purple-400' : 'text-slate-500 hover:text-purple-400'}`}><Volume2 className="w-4 h-4" /></button><span className={`md:hidden text-xs font-bold px-2 py-0.5 rounded-full ${record.isCorrect ? 'bg-green-900 text-green-400' : 'bg-red-900 text-red-400'}`}>{record.isCorrect ? (record.isAiCorrect ? "AI 인정" : "정답") : "오답"}</span></div><div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm"><div className="flex flex-col"><span className="text-slate-500 text-xs">내 답안</span><span className={`font-medium ${record.isCorrect ? 'text-slate-300' : 'text-red-300 line-through'}`}>{record.userInput || "(미입력)"}</span></div><div className="flex flex-col"><span className="text-slate-500 text-xs">진짜 정답</span><span className="font-medium text-purple-300">{currentWordState.definition}</span></div></div>{record.aiFeedback && (<div className={`mt-2 text-xs px-3 py-2 rounded-lg flex items-start gap-2 ${record.isCorrect ? 'bg-indigo-900/20 text-indigo-300' : 'bg-red-900/20 text-red-300'}`}><Lightbulb className="w-3 h-3 mt-0.5 shrink-0"/><span><span className="font-bold">AI 채점:</span> {record.aiFeedback}</span></div>)}</div></div>); })}</div><div className="mt-8 flex flex-col gap-3">{hasNextBatch && (<button onClick={() => { onSave({ correct: correctIds, incorrect: incorrectIds }); onNextBatch?.(); }} className="w-full py-4 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-xl transition-all shadow-lg shadow-purple-900/30 flex justify-center gap-2 animate-pulse-glow"><FastForward className="w-5 h-5"/> 다음 문제 풀기</button>)}<div className="grid grid-cols-2 gap-3"><button onClick={() => { onRetry('ALL', { correct: correctIds, incorrect: incorrectIds }); }} className="py-4 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-xl transition-colors flex justify-center gap-2"><Shuffle className="w-5 h-5"/> 전체 재도전</button>{incorrectIds.length > 0 && (<button onClick={() => onRetry('INCORRECT', { correct: correctIds, incorrect: incorrectIds })} className="py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded-xl transition-colors shadow-lg shadow-red-900/30 flex justify-center gap-2"><RotateCcw className="w-5 h-5"/> 오답만 풀기</button>)}</div><button onClick={() => { onSave({ correct: correctIds, incorrect: incorrectIds }); onExit(); }} className={`py-4 bg-slate-800 hover:bg-slate-700 border border-slate-700 text-slate-300 font-bold rounded-xl transition-colors flex justify-center gap-2`}><Home className="w-5 h-5"/> 학습 종료 (저장)</button></div></div></div></div>); }
  const progress = ((currentIndex) / words.length) * 100;
  return (<div className="max-w-xl mx-auto p-4 animate-fade-in relative min-h-[calc(100vh-100px)] flex flex-col justify-center"><button onClick={onExit} className="absolute top-0 right-4 text-slate-500 hover:text-white text-sm transition-colors z-10">나가기 (저장 안됨)</button>{timeLeft !== undefined && (<div className="flex justify-between items-center mb-2 px-1"><span className="flex items-center gap-1.5 text-xs font-bold text-yellow-400 uppercase tracking-widest animate-pulse"><Clock className="w-3 h-3"/> Speed Mode</span><span className={`text-sm font-mono font-bold ${timeLeft <= 10 ? 'text-red-500 animate-bounce' : 'text-slate-400'}`}>{Math.floor(timeLeft / 60)}:{(timeLeft % 60).toString().padStart(2, '0')}</span></div>)}<div className="w-full bg-slate-800 h-2 rounded-full mb-8 border border-slate-700 relative overflow-hidden"><div className="bg-purple-500 h-2 rounded-full transition-all duration-300" style={{ width: `${progress}%` }}></div>{timeLimit && timeLeft !== undefined && (<div className="absolute top-0 left-0 h-full bg-yellow-500/50 transition-all duration-1000 ease-linear" style={{ width: `${(timeLeft / timeLimit) * 100}%` }}></div>)}</div><div className="bg-slate-900 border border-slate-700 rounded-2xl p-8 shadow-xl text-center relative overflow-hidden"><div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 opacity-50"></div><div className="relative mb-6 flex justify-end items-center h-8"><div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2"><span className="text-slate-500 text-xs font-bold tracking-widest uppercase bg-slate-800 px-3 py-1 rounded-full">Question {currentIndex + 1} / {words.length}</span></div><button onClick={() => speak(currentWord.term)} className={`p-2 rounded-full transition-colors z-10 ${isSpeaking ? 'text-purple-400 bg-purple-900/30' : 'text-slate-400 hover:text-purple-400 hover:bg-slate-800'}`} title="발음 듣기 (AI)" disabled={isSpeaking}>{isSpeaking ? <Loader2 className="w-6 h-6 animate-spin" /> : <Volume2 className="w-6 h-6" />}</button></div><div className="mb-10 min-h-[120px] flex flex-col justify-center items-center relative"><button onClick={() => onToggleFavorite(currentWord.id)} className="mb-2 p-2 hover:bg-slate-800 rounded-full transition-colors group"><Star className={`w-6 h-6 transition-transform group-hover:scale-110 ${currentWord.isFavorite ? 'fill-yellow-400 text-yellow-400' : 'text-slate-600'}`} /></button><h2 className="text-4xl md:text-5xl font-bold text-white mb-4 break-words animate-slide-up leading-tight">{currentWord.term}</h2><p className="text-slate-400 text-sm font-medium">{quizMode === 'MULTIPLE_CHOICE' ? '알맞은 뜻을 선택하세요' : quizMode === 'OX' ? '뜻이 올바른지 확인하세요' : '뜻을 입력하세요'}</p></div><div className="space-y-6 w-full animate-fade-in">{quizMode === 'TYPING' ? (<><div className="relative"><input ref={inputRef} type="text" value={currentInput} onChange={(e) => setCurrentInput(e.target.value)} placeholder={showHint ? getChosung(currentWord.definition) : "정답 입력..."} className="w-full bg-slate-800 text-white text-xl p-4 rounded-xl border-2 border-slate-700 focus:border-purple-500 outline-none text-center placeholder:text-slate-600 transition-all shadow-inner" autoComplete="off" autoFocus/>{!showHint && (<button onClick={() => setShowHint(true)} className="absolute right-4 top-1/2 -translate-y-1/2 text-slate-500 hover:text-yellow-400 transition-colors"><Lightbulb className="w-5 h-5" /></button>)}</div><button type="button" onClick={() => submitAnswerWithLogic(currentInput)} className="mt-6 w-full py-4 bg-slate-800 hover:bg-slate-700 border border-slate-600 hover:border-purple-500 text-white font-bold rounded-xl transition-all flex items-center justify-center gap-2 group active:scale-95">다음 문제 (Enter) <ArrowRight className="w-5 h-5 group-hover:translate-x-1 transition-transform" /></button></>) : quizMode === 'OX' ? (<div><div className="bg-slate-800 p-6 rounded-xl border border-slate-700 mb-8 min-h-[100px] flex items-center justify-center shadow-inner"><span className="text-2xl text-indigo-200 font-medium break-keep">{oxState.displayedDefinition}</span></div><div className="grid grid-cols-2 gap-6"><button onClick={() => submitAnswerWithLogic(true)} className="aspect-square flex flex-col items-center justify-center bg-slate-800 hover:bg-green-900/30 border border-slate-700 hover:border-green-500 rounded-2xl transition-all group active:scale-95"><div className="w-16 h-16 rounded-full border-4 border-green-500 flex items-center justify-center mb-2 bg-green-500/10"><div className="w-8 h-8 rounded-full border-4 border-green-500"></div></div><span className="text-green-400 font-bold text-xl">맞음 (O)</span></button><button onClick={() => submitAnswerWithLogic(false)} className="aspect-square flex flex-col items-center justify-center bg-slate-800 hover:bg-red-900/30 border border-slate-700 hover:border-red-500 rounded-2xl transition-all group active:scale-95"><div className="w-16 h-16 rounded-full relative mb-2"><X className="w-full h-full text-red-500" strokeWidth={3}/></div><span className="text-red-400 font-bold text-xl">틀림 (X)</span></button></div></div>) : (<div className="grid grid-cols-1 gap-3">{options.map((option, idx) => (<button key={idx} onClick={() => submitAnswerWithLogic(option)} className="w-full p-4 bg-slate-800 hover:bg-slate-700 border border-slate-700 hover:border-purple-500 text-white text-lg rounded-xl transition-all text-left flex items-center gap-3 group active:scale-95"><span className="w-8 h-8 flex items-center justify-center bg-slate-900 rounded-full text-sm font-bold text-slate-400 group-hover:text-purple-400 group-hover:bg-purple-900/30 transition-colors border border-slate-700">{idx + 1}</span><span className="flex-1">{option}</span></button>))}</div>)}</div></div></div>);
};

export default QuizMode;